# Тестовое задание для VK

Выполнил: __Дмитрий Абрамов__


Непосредственно алгоритм в файле `src/common_elements.cpp`.

Тесты в файле `src/common_elements_test.cpp`.

### Запуск:

Собрать с помощью `cmake CMakeLists.txt && make`.

Запускать `common_elements`.
Для запуска тестов запустить с флагом `--test` или `-t`.

### Алгоритм

Пусть массив меньшей длины - это `A`, другой массив - это `B`. Их длины соответственно: `|A|` и `|B|`.

- Кладем все элементы `A` в хеш-таблицу.
- Итерируемся по элементам `B`: если элемент в таблице есть - увеличиваем счетчик общих элементов.
- В итоге в счетчике хранится нужное нам значение.

Асимптотика времени работы `O(|A| + |B|)`:

Операции вставки и поиска в хеш-таблице занимает в среднем `O(1)` времени.
На практике - ощутимая константа, но все же лучше, чем `log`.

Итого построение хеш-таблицы занимает `O(|A|)`, итерирование по `B` и поиск - `O(|B|)`.

### Почему этот алгоритм
Это наилучшая асимптотика, возможная для этой задачи.

Несмотря на ощутимую константу хеш-таблицы - это все же достаточно быстро. (Хотя провести сравнительный benchmarking не помешает). 

Также алгоритм не модифицирует исходные данные.

### Другие варианты

1. В качестве множества можно использовать не хеш-таблицу а бинарное дерево поиска с балансировкой (например красно-черное дерево `std::set`). 
Асимптотика такого решения: `O((|A| + |B|) * log(|A|))`.
2. Так же при достаточно небольшом `|A|` эффективно будет отсортировать `A` и искать по нему бинарным поиском (все остальное - как в предложенном алгоритме). Константа тут маленькая. 
3. Можно отсортировать оба массива и пройти по ним двумя указателями за `O(время сортировки + |A| + |B|)`. 
Хотя использование поразрядной сортировки (radix sort) в случае `int` позволило бы добиться того же времени `O(|A| + |B|)`, но опять же, довольно ощутимая константа.
Но здесь при прочих равных - или больше дополнительной памяти или модификация входных данных. 
